// Print page script - prepares content and signals background for PDF generation

import { getLargeData, removeLargeData } from '../scripts/utils/storage.js';
import { cleanTitleForFilename, escapeHtml } from '../scripts/utils/html.js';
import { getUILanguage, tSync } from '../scripts/locales.js';

const LOG_PREFIX = '[ClipAIble:Print]';

/**
 * Log message to service worker with console fallback
 * Note: console.log is used as fallback when service worker is unavailable (acceptable in print page context)
 * @param {string} message - Log message
 * @param {*} data - Optional data to log
 */
function log(message, data = null) {
  const logMessage = `${LOG_PREFIX} ${message}`;
  
  // CRITICAL: ALL logs MUST go to service worker - this is the primary logging destination
  // Console.log is secondary fallback, service worker logs are primary
  // Note: console.log is acceptable here as fallback when service worker is unavailable
  try {
    chrome.runtime.sendMessage({
      action: 'logFromPrintPage',
      data: {
        message: logMessage,
        data: data
      }
    }).catch(() => {
      // Fallback to console if service worker is not available (acceptable in print page context)
      console.log(logMessage, data || '');
    });
  } catch (e) {
    // Fallback to console if sendMessage fails (acceptable in print page context)
    console.log(logMessage, data || '');
  }
}

async function init() {
  // NOTE: setTimeout delays below (200ms, 300ms) are render/reflow waits.
  // They are NOT magic numbers to extract - contextually clear, used once.
  log('=== INIT START ===');
  
  // Load UI language and update loading text
  try {
    const uiLang = await getUILanguage();
    const loadingText = tSync('loadingArticle', uiLang);
    const loadingElement = document.getElementById('loadingText');
    const titleElement = document.getElementById('pageTitle');
    if (loadingElement) loadingElement.textContent = loadingText;
    if (titleElement) titleElement.textContent = loadingText;
  } catch (error) {
    log('Failed to load localization for print page', error);
  }
  
  try {
    // Get HTML from storage (checks both chrome.storage and IndexedDB)
    const printHtml = await getLargeData('printHtml');
    
    if (!printHtml) {
      throw new Error('No content in storage');
    }
    
    // Get metadata from chrome.storage
    const result = await chrome.storage.local.get(['printTitle', 'pageMode']);
    
    // Use cleanTitleForFilename to remove invalid filename chars (print page title is used for PDF filename)
    const title = cleanTitleForFilename(typeof result.printTitle === 'string' ? result.printTitle : undefined, 'Untitled');
    const pageMode = (typeof result.pageMode === 'string' ? result.pageMode : undefined) || 'single';
    
    log(`Content loaded: ${printHtml.length} chars, pageMode=${pageMode}`);
    
    // CRITICAL: Log first paragraph from HTML before writing to document
    const firstParagraphMatch = printHtml.match(/<p[^>]*>([^<]+)/);
    if (firstParagraphMatch) {
      log(`=== FIRST PARAGRAPH IN HTML (BEFORE document.write) === ${firstParagraphMatch[1]}`);
    }
    
    // Write HTML to document
    // SECURITY NOTE: printHtml is generated by buildHtmlForPdf() which uses sanitizeHtml() and escapeAttr()
    // for all content. HTML is sanitized before being saved to storage, so document.write is safe here.
    // document.write is necessary for full document replacement (including DOCTYPE), innerHTML cannot replace DOCTYPE.
    document.open();
    document.write(printHtml);
    document.close();
    document.title = title;
    
    log('Document written');
    
    // Wait for render
    await new Promise(r => setTimeout(r, 300));
    
    // CRITICAL: Check first paragraph in DOM after document.write
    const firstParagraph = document.querySelector('.article-content p, article p, .article p');
    if (firstParagraph) {
      const firstParagraphText = firstParagraph.textContent || '';
      const firstParagraphHTML = firstParagraph.innerHTML || '';
      const hasDataOriginalText = firstParagraph.hasAttribute('data-original-text');
      const dataOriginalText = firstParagraph.getAttribute('data-original-text') || null;
      const hasGtOrig = firstParagraph.hasAttribute('data-gt-orig-display');
      const gtOrig = firstParagraph.getAttribute('data-gt-orig-display') || null;
      
      log(`=== FIRST PARAGRAPH IN DOM (AFTER document.write) ===`);
      log(`  textContent: ${firstParagraphText}`);
      log(`  innerHTML: ${firstParagraphHTML}`);
      log(`  hasDataOriginalText: ${hasDataOriginalText}`);
      log(`  dataOriginalText: ${dataOriginalText}`);
      log(`  hasGtOrig: ${hasGtOrig}`);
      log(`  gtOrig: ${gtOrig}`);
      
      // Check if Google Translate modified the text
      if (hasDataOriginalText && dataOriginalText && dataOriginalText !== firstParagraphText) {
        log(`!!! WARNING: Google Translate modified first paragraph !!!`);
        log(`  Original: ${dataOriginalText}`);
        log(`  Translated: ${firstParagraphText}`);
      }
    }
    
    // Check for Google Translate widget
    const googleTranslateWidget = document.querySelector('[class*="goog-te"], [id*="google_translate"]');
    if (googleTranslateWidget) {
      log(`!!! WARNING: Google Translate widget detected in DOM !!!`);
    }
    
    // Wait for images
    const images = document.querySelectorAll('img');
    log(`Waiting for ${images.length} images...`);
    
    await Promise.all(Array.from(images).map(img => {
      return new Promise(resolve => {
        if (img.complete) resolve();
        else {
          img.onload = resolve;
          img.onerror = resolve;
        }
      });
    }));
    
    log('Images loaded');
    await new Promise(r => setTimeout(r, 200));
    
    // Get article element
    const articleElement = document.querySelector('.article') || document.body;
    const article = articleElement instanceof HTMLElement ? articleElement : document.body;
    
    // For single page mode, fix width to match print layout
    // @media print has padding: 5mm on body = 19px on each side
    // So content width = A4 width - 2*padding = 794 - 38 = 756px
    if (pageMode === 'single') {
      const printPaddingPx = 19; // 5mm at 96dpi
      const a4WidthPx = 794; // 8.27 inches * 96 dpi
      const contentWidthPx = a4WidthPx - (printPaddingPx * 2);
      
      article.style.width = contentWidthPx + 'px';
      article.style.maxWidth = contentWidthPx + 'px';
      document.body.style.width = contentWidthPx + 'px';
      
      // Wait for reflow
      await new Promise(r => setTimeout(r, 200));
      log(`Fixed width to ${contentWidthPx}px (A4 minus padding)`);
    }
    
    // Measure content height accurately
    const contentWidth = article.offsetWidth;
    
    // Get multiple height measurements
    const articleScrollH = article.scrollHeight;
    const articleOffsetH = article.offsetHeight;
    const bodyScrollH = document.body.scrollHeight;
    const documentH = document.documentElement.scrollHeight;
    
    // Use the most accurate height - typically scrollHeight is most reliable
    // But compare with body height to catch any outliers
    const contentHeight = Math.ceil(Math.min(articleScrollH, bodyScrollH, documentH));
    
    log(`Height measurements: articleScroll=${articleScrollH}, articleOffset=${articleOffsetH}, bodyScroll=${bodyScrollH}, doc=${documentH}, using=${contentHeight}`);
    
    log(`Content dimensions: ${contentWidth}x${contentHeight}px`);
    
    // CRITICAL: Check first paragraph again before PDF generation
    const firstParagraphBeforePdf = document.querySelector('.article-content p, article p, .article p');
    if (firstParagraphBeforePdf) {
      const firstParagraphTextBeforePdf = firstParagraphBeforePdf.textContent || '';
      const firstParagraphHTMLBeforePdf = firstParagraphBeforePdf.innerHTML || '';
      const hasDataOriginalTextBeforePdf = firstParagraphBeforePdf.hasAttribute('data-original-text');
      const dataOriginalTextBeforePdf = firstParagraphBeforePdf.getAttribute('data-original-text') || null;
      
      log(`=== FIRST PARAGRAPH IN DOM (BEFORE PDF GENERATION) ===`);
      log(`  textContent: ${firstParagraphTextBeforePdf}`);
      log(`  innerHTML: ${firstParagraphHTMLBeforePdf}`);
      log(`  hasDataOriginalText: ${hasDataOriginalTextBeforePdf}`);
      log(`  dataOriginalText: ${dataOriginalTextBeforePdf}`);
      
      // Check all paragraphs for Google Translate modifications
      const allParagraphs = document.querySelectorAll('.article-content p, article p, .article p');
      let modifiedCount = 0;
      allParagraphs.forEach((p, idx) => {
        const hasDataOriginalText = p.hasAttribute('data-original-text');
        const dataOriginalText = p.getAttribute('data-original-text');
        if (hasDataOriginalText && dataOriginalText && dataOriginalText !== p.textContent) {
          modifiedCount++;
          if (idx === 0) {
            log(`!!! PARAGRAPH [${idx}] MODIFIED BY GOOGLE TRANSLATE !!!`);
            log(`  Original: ${dataOriginalText}`);
            log(`  Translated: ${p.textContent}`);
          }
        }
      });
      if (modifiedCount > 0) {
        log(`!!! WARNING: ${modifiedCount} paragraphs modified by Google Translate !!!`);
      }
    }
    
    // Send message to background to generate PDF via debugger
    log('Requesting PDF generation from background...');
    
    const response = await chrome.runtime.sendMessage({
      action: 'generatePdfDebugger',
      data: {
        title: title,
        pageMode: pageMode,
        contentWidth: contentWidth,
        contentHeight: contentHeight
      }
    });
    
    if (response && response.success) {
      log('PDF generation started');
      // Tab will be closed by background script after PDF is saved
    } else {
      throw new Error(response?.error || 'PDF generation failed');
    }
    
    log('=== DONE ===');
    
  } catch (error) {
    // CRITICAL: Error logs MUST also go to service worker
    log(`ERROR: ${error.message}`, { error: error.toString(), stack: error.stack });
    // Load localized error messages
    try {
      const uiLang = await getUILanguage();
      const errorTitle = tSync('errorPrintPage', uiLang);
      const unknownErrorText = tSync('unknownError', uiLang);
      // SECURITY: Escape error message to prevent XSS attacks
      const safeErrorMessage = escapeHtml(error.message || unknownErrorText);
      document.body.innerHTML = `<div style="padding:40px;color:red;font-family:sans-serif;">
        <h2>${escapeHtml(errorTitle)}</h2>
        <p>${safeErrorMessage}</p>
      </div>`;
    } catch (localizationError) {
      // Fallback to English if localization fails
      log('Failed to load localized error messages', localizationError);
      const safeErrorMessage = escapeHtml(error.message || 'Unknown error');
      document.body.innerHTML = `<div style="padding:40px;color:red;font-family:sans-serif;">
        <h2>Error</h2>
        <p>${safeErrorMessage}</p>
      </div>`;
    }
  } finally {
    // Always clean up storage, even if error occurred
    try {
      await removeLargeData('printHtml');
      await chrome.storage.local.remove(['printTitle', 'pageMode']);
      log('Storage cleaned up');
    } catch (cleanupError) {
      log(`Failed to clean up storage: ${cleanupError.message}`);
    }
  }
}

init();
